### GO PROJECT CONTEXT (ROOT FILES ONLY)
### Generated at: Mon Dec 22 11:24:40 UTC 2025

==================================================
FILE: builder.go
==================================================

package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// HandleBuild orchestrates the build process
func HandleBuild(sourceDir, outputName string) error {
	// 1. Resolve Absolute Paths to avoid confusion when changing directories
	absSourceDir, err := filepath.Abs(sourceDir)
	if err != nil {
		return fmt.Errorf("failed to get absolute path of source: %w", err)
	}

	// Default output name handling
	if outputName == "" {
		outputName = "main.wasm"
	}
	if !strings.HasSuffix(outputName, ".wasm") {
		outputName += ".wasm"
	}

	absOutputName, err := filepath.Abs(outputName)
	if err != nil {
		return fmt.Errorf("failed to get absolute path of output: %w", err)
	}

	fmt.Printf("DEBUG: HandleBuild context\n  Source: %s\n  Output: %s\n", absSourceDir, absOutputName)

	fmt.Printf("ðŸ” Scanning project in: %s\n", absSourceDir)
	generatedCode, err := GenerateCode(absSourceDir)
	if err != nil {
		fmt.Printf("DEBUG: GenerateCode returned error: %v\n", err)
		return fmt.Errorf("code generation failed: %w", err)
	}

	// The temporary file will be created INSIDE the source directory
	tmpFileName := "generated_build.go"
	tmpFilePath := filepath.Join(absSourceDir, tmpFileName)

	fmt.Println("ðŸ“ Writing intermediate build file...")
	if err := WriteToFile(tmpFilePath, generatedCode); err != nil {
		return fmt.Errorf("failed to write generated file '%s': %w", tmpFilePath, err)
	}

	// // --- Temporary File Cleanup ---
	// // COMMENT OUT this block to keep the generated file for debugging/analysis
	// defer func() {
	// 	fmt.Printf("ðŸ§¹ Cleaning up temporary file: %s\n", tmpFilePath)
	// 	if err := os.Remove(tmpFilePath); err != nil {
	// 		fmt.Printf("âš ï¸ Warning: Failed to clean up temporary file '%s': %v\n", tmpFilePath, err)
	// 	}
	// }()
	// // ------------------------------

	// --- TinyGo Compilation ---
	args := []string{
		"build", "-size", "short", "-no-debug",
		"-o", absOutputName, // Use absolute path for output so it writes to the correct place
		"-target", "wasm-unknown",
		tmpFileName, // Just the filename, because we will run command INSIDE absSourceDir
	}

	fmt.Printf("ðŸ”¨ Compiling to %s...\n", outputName)

	// Execute TinyGo inside the contract directory
	// passing absSourceDir as the 'dir' argument
	if err := ExecuteWithRetry("tinygo", args, absSourceDir, 2, os.Getenv("DEBUG") != ""); err != nil {
		fmt.Printf("DEBUG: TinyGo compilation failed: %v\n", err)
		return err
	}

	// --- Verification ---
	if _, err := os.Stat(absOutputName); os.IsNotExist(err) {
		return fmt.Errorf("%s: output file '%s' not found after build", ErrWasmNotFound, absOutputName)
	}

	fmt.Printf("âœ… Build completed successfully: %s\n", outputName)
	return nil
}

// HandleTests runs the tests for the smart contract.
func HandleTests(testType string) error {
	target := "./..."
	if testType == "package" {
		target = "./"
	} else if testType != "project" {
		return fmt.Errorf("invalid test type provided: '%s'. Use 'project' or 'package'.", testType)
	}

	fmt.Printf("ðŸ§ª Running %s tests...\n", testType)

	// Pass "" as dir to run in current working directory
	if err := ExecuteWithRetry("tinygo", append([]string{"test"}, target), "", 2, true); err != nil {
		return fmt.Errorf("tests failed: %w", err)
	}

	fmt.Println("âœ… Tests passed!")
	return nil
}



==================================================
FILE: codegen.go
==================================================

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

// MethodInfo holds parsed method information
type MethodInfo struct {
	Name         string
	ReceiverType string
	Params       []Param
	Returns      []string
	IsPublic     bool
	IsPrivate    bool
	IsView       bool
	IsMutating   bool
	IsPayable    bool
	IsInit       bool // Tracks @contract:init
	MinDeposit   string
	FilePath     string
	RelativePath string
	SourceCode   string
}

type Param struct {
	Name string
	Type string
}

// StateInfo holds contract state struct information
type StateInfo struct {
	Name         string
	Fields       []FieldInfo
	FilePath     string
	RelativePath string
	SourceCode   string
}

type FieldInfo struct {
	Name string
	Type string
}

// FileContent holds all declarations from a file
type FileContent struct {
	FilePath     string
	RelativePath string
	Declarations []string
	Imports      []string
	IsStateFile  bool
}

// GenerateCode scans the directory and generates the Go code
func GenerateCode(rootDir string) (string, error) {
	fmt.Printf("DEBUG: CodeGen scanning directory: %s\n", rootDir)

	allMethods, stateStructs, fileContents, err := parseAllFilesRecursive(rootDir)
	if err != nil {
		return "", err
	}

	if len(allMethods) == 0 && len(stateStructs) == 0 {
		return "", fmt.Errorf("no methods or state structs with @contract annotations found")
	}

	fmt.Printf("DEBUG: Found %d State Structs and %d Public Methods\n", len(stateStructs), countPublicMethods(allMethods))

	return generateCode(allMethods, stateStructs, fileContents), nil
}

func countPublicMethods(methods []*MethodInfo) int {
	count := 0
	for _, m := range methods {
		if m.IsPublic || m.IsInit {
			count++
		}
	}
	return count
}

func parseAllFilesRecursive(rootDir string) ([]*MethodInfo, []*StateInfo, []*FileContent, error) {
	var allMethods []*MethodInfo
	var stateStructs []*StateInfo
	var fileContents []*FileContent

	err := filepath.WalkDir(rootDir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return err
		}

		if d.IsDir() {
			name := d.Name()
			if strings.HasPrefix(name, ".") && name != "." && name != "./" {
				return filepath.SkipDir
			}
			if name == "vendor" || name == "node_modules" || name == "testdata" {
				return filepath.SkipDir
			}
			return nil
		}

		if !strings.HasSuffix(path, ".go") || strings.HasSuffix(path, "_test.go") {
			return nil
		}
		if strings.HasPrefix(filepath.Base(path), "generated_") {
			return nil
		}

		relPath, _ := filepath.Rel(rootDir, path)

		methods, states, content, err := parseContract(path, relPath)
		if err != nil {
			fmt.Printf("DEBUG: Failed to parse %s: %v\n", relPath, err)
			return nil
		}

		if content == nil {
			return nil
		}

		if len(methods) > 0 {
			allMethods = append(allMethods, methods...)
		}

		if len(states) > 0 {
			stateStructs = append(stateStructs, states...)
			content.IsStateFile = true
		}

		fileContents = append(fileContents, content)
		return nil
	})

	return allMethods, stateStructs, fileContents, err
}

func parseContract(filePath string, relativePath string) ([]*MethodInfo, []*StateInfo, *FileContent, error) {
	fileContentBytes, err := os.ReadFile(filePath)
	if err != nil {
		return nil, nil, nil, err
	}

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		return nil, nil, nil, err
	}

	if file.Name.Name != "main" {
		return nil, nil, nil, nil
	}

	var methods []*MethodInfo
	var stateStructs []*StateInfo
	content := &FileContent{
		FilePath:     filePath,
		RelativePath: relativePath,
		Declarations: []string{},
		Imports:      []string{},
	}

	for _, imp := range file.Imports {
		startPos := fset.Position(imp.Pos()).Offset
		endPos := fset.Position(imp.End()).Offset
		content.Imports = append(content.Imports, string(fileContentBytes[startPos:endPos]))
	}

	for _, decl := range file.Decls {
		switch d := decl.(type) {
		case *ast.GenDecl:
			if d.Tok == token.IMPORT {
				continue
			}
			startPos := fset.Position(d.Pos()).Offset
			endPos := fset.Position(d.End()).Offset
			declCode := string(fileContentBytes[startPos:endPos])

			if d.Tok == token.TYPE {
				for _, spec := range d.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}

					isState := false
					if d.Doc != nil && hasStateAnnotation(d.Doc) {
						isState = true
					} else if typeSpec.Doc != nil && hasStateAnnotation(typeSpec.Doc) {
						isState = true
					}

					if isState {
						structType, ok := typeSpec.Type.(*ast.StructType)
						if !ok {
							continue
						}
						state := extractStateInfo(typeSpec, structType, fset, fileContentBytes)
						state.FilePath = filePath
						state.RelativePath = relativePath
						stateStructs = append(stateStructs, state)
					}
				}
			}
			content.Declarations = append(content.Declarations, declCode)

		case *ast.FuncDecl:
			startPos := fset.Position(d.Pos()).Offset
			endPos := fset.Position(d.End()).Offset
			declCode := string(fileContentBytes[startPos:endPos])

			if d.Recv != nil && len(d.Recv.List) > 0 {
				method := extractMethodWithSource(d, fset, fileContentBytes)
				method.FilePath = filePath
				method.RelativePath = relativePath

				if method.IsPublic || method.IsView || method.IsMutating || method.IsPayable || method.IsPrivate || method.IsInit {
					methods = append(methods, method)
				}
			}
			content.Declarations = append(content.Declarations, declCode)
		}
	}

	return methods, stateStructs, content, nil
}

func hasStateAnnotation(doc *ast.CommentGroup) bool {
	if doc == nil {
		return false
	}
	for _, comment := range doc.List {
		text := strings.TrimSpace(strings.TrimPrefix(strings.TrimSpace(comment.Text), "//"))
		if strings.Contains(text, "@contract:state") {
			return true
		}
	}
	return false
}

func extractStateInfo(typeSpec *ast.TypeSpec, structType *ast.StructType, fset *token.FileSet, fileContent []byte) *StateInfo {
	state := &StateInfo{Name: typeSpec.Name.Name}
	if structType.Fields != nil {
		for _, field := range structType.Fields.List {
			fieldType := typeToString(field.Type)
			for _, name := range field.Names {
				state.Fields = append(state.Fields, FieldInfo{Name: name.Name, Type: fieldType})
			}
		}
	}
	startPos := fset.Position(typeSpec.Pos()).Offset
	endPos := fset.Position(structType.End()).Offset
	state.SourceCode = string(fileContent[startPos:endPos])
	return state
}

func extractMethodWithSource(fn *ast.FuncDecl, fset *token.FileSet, fileContent []byte) *MethodInfo {
	method := &MethodInfo{Name: fn.Name.Name}
	if fn.Recv != nil && len(fn.Recv.List) > 0 {
		method.ReceiverType = extractReceiverType(fn.Recv.List[0].Type)
	}
	if fn.Doc != nil {
		for _, comment := range fn.Doc.List {
			parseAnnotation(comment.Text, method)
		}
	}
	if fn.Type.Params != nil {
		for _, field := range fn.Type.Params.List {
			typeName := typeToString(field.Type)
			for _, name := range field.Names {
				method.Params = append(method.Params, Param{Name: name.Name, Type: typeName})
			}
		}
	}
	if fn.Type.Results != nil {
		for _, field := range fn.Type.Results.List {
			method.Returns = append(method.Returns, typeToString(field.Type))
		}
	}
	startPos := fset.Position(fn.Pos()).Offset
	endPos := fset.Position(fn.End()).Offset
	method.SourceCode = string(fileContent[startPos:endPos])
	return method
}

func extractReceiverType(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return extractReceiverType(t.X)
	default:
		return "Unknown"
	}
}

func parseAnnotation(text string, method *MethodInfo) {
	text = strings.TrimSpace(strings.TrimPrefix(strings.TrimSpace(text), "//"))
	if !strings.HasPrefix(text, "@contract:") {
		return
	}
	parts := strings.Fields(strings.TrimPrefix(text, "@contract:"))
	if len(parts) == 0 {
		return
	}
	switch parts[0] {
	case "init":
		method.IsInit = true
		method.IsMutating = true // Init is always mutating
		method.IsPublic = true   // Init is always public
	case "public":
		method.IsPublic = true
	case "private":
		method.IsPrivate = true
	case "view":
		method.IsView = true
	case "mutating":
		method.IsMutating = true
	case "payable":
		method.IsPayable = true
		for _, part := range parts[1:] {
			if strings.HasPrefix(part, "min_deposit=") {
				method.MinDeposit = strings.TrimPrefix(part, "min_deposit=")
			}
		}
	}
}

func typeToString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + typeToString(t.X)
	case *ast.ArrayType:
		return "[]" + typeToString(t.Elt)
	case *ast.SelectorExpr:
		return typeToString(t.X) + "." + t.Sel.Name
	case *ast.MapType:
		return "map[" + typeToString(t.Key) + "]" + typeToString(t.Value)
	case *ast.InterfaceType:
		return "interface{}"
	default:
		return "unknown"
	}
}

func generateCode(methods []*MethodInfo, stateStructs []*StateInfo, fileContents []*FileContent) string {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by NEAR contract generator. DO NOT EDIT.\n")
	sb.WriteString("// This file uses encoding/json for parameter parsing instead of Borsh.\n\n")
	sb.WriteString("package main\n\n")

	importMap := make(map[string]bool)
	importMap["contractBuilder \"github.com/vlmoon99/near-sdk-go/contract\""] = true
	importMap["\"github.com/vlmoon99/near-sdk-go/env\""] = true
	importMap["\"github.com/vlmoon99/near-sdk-go/borsh\""] = true
	importMap["\"github.com/vlmoon99/near-sdk-go/types\""] = true
	importMap["encodingJson \"encoding/json\""] = true
	importMap["\"strconv\""] = true

	for _, content := range fileContents {
		for _, imp := range content.Imports {
			cleanImp := strings.TrimSpace(imp)
			if cleanImp != "" {
				importMap[cleanImp] = true
			}
		}
	}

	sb.WriteString("import (\n")
	for imp := range importMap {
		sb.WriteString("\t" + imp + "\n")
	}
	sb.WriteString(")\n\n")

	// 1. Declarations
	for _, content := range fileContents {
		sb.WriteString(fmt.Sprintf("// ===== From: %s =====\n", content.RelativePath))
		for _, decl := range content.Declarations {
			sb.WriteString(decl)
			sb.WriteString("\n\n")
		}
	}

	// 2. State helpers
	if len(stateStructs) > 0 {
		state := stateStructs[0]
		sb.WriteString(generateDefaultInit(state))
		sb.WriteString("\n")
		sb.WriteString(generateGetState(state))
		sb.WriteString("\n")
		sb.WriteString(generateSetState(state))
		sb.WriteString("\n")
	}

	// 3. Exported functions
	sb.WriteString("// ===== Generated Exports =====\n")
	for _, m := range methods {
		if !m.IsPublic && !m.IsInit {
			continue
		}
		sb.WriteString(generateExportFunction(m, stateStructs))
		sb.WriteString("\n")
	}

	// 4. Helper functions
	sb.WriteString("// ===== Helper Functions =====\n")
	sb.WriteString(generateValidatePayment())
	sb.WriteString("\n")

	return sb.String()
}

// Generates the default zero-value init function
func generateDefaultInit(state *StateInfo) string {
	return fmt.Sprintf(`func defaultInit() *%s {
	return &%s{}
}`, state.Name, state.Name)
}

func generateGetState(state *StateInfo) string {
	return fmt.Sprintf(`func getState() *%s {
	val, err := env.StateRead()
	if err != nil || len(val) == 0 {
		return defaultInit()
	}
	var state %s
	err = borsh.Deserialize(val, &state)
	if err != nil {
		env.PanicStr("Failed to deserialize state")
	}
	return &state
}`, state.Name, state.Name)
}

func generateSetState(state *StateInfo) string {
	return fmt.Sprintf(`func setState(state *%s) {
	val, err := borsh.Serialize(state)
	if err != nil {
		env.PanicStr("Failed to serialize state")
	}
	err = env.StateWrite(val)
	if err != nil {
		env.PanicStr("Failed to write state")
	}
}`, state.Name)
}

func generateValidatePayment() string {
	return `func validatePayment(minDeposit string) bool {
	minAmount, err := strconv.ParseFloat(minDeposit, 64)
	if err != nil {
		env.LogString("Invalid min deposit amount: " + minDeposit)
		return false
	}
	minYocto := minAmount * 1e24
	minYoctoStr := strconv.FormatFloat(minYocto, 'f', 0, 64)
	minRequired, err := types.U128FromString(minYoctoStr)
	if err != nil {
		env.LogString("Failed to create Uint128: " + err.Error())
		return false
	}
	attachedDeposit, err := env.GetAttachedDeposit()
	if attachedDeposit.Cmp(minRequired) < 0 {
		env.LogString("Insufficient payment")
		return false
	}
	return true
}`
}

func generateExportFunction(m *MethodInfo, stateStructs []*StateInfo) string {
	var sb strings.Builder

	exportName := toSnakeCase(m.Name)
	sb.WriteString(fmt.Sprintf("// Export: %s (from %s)\n", exportName, m.RelativePath))
	sb.WriteString(fmt.Sprintf("//go:export %s\n", exportName))
	sb.WriteString(fmt.Sprintf("func %s() {\n", exportName))
	sb.WriteString("\tcontractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {\n")

	// If it is an @contract:init method, we must ensure state does NOT exist
	if m.IsInit {
		sb.WriteString("\t\t// Initialization: Check if already initialized\n")
		sb.WriteString("\t\texistingVal, _ := env.StateRead()\n")
		sb.WriteString("\t\tif len(existingVal) > 0 {\n")
		sb.WriteString("\t\t\tenv.PanicStr(\"Contract already initialized\")\n")
		sb.WriteString("\t\t}\n")
		// For init, we start with a clean default state to run the method on
		sb.WriteString("\t\tstate := defaultInit()\n\n")
	} else {
		// Normal method: load state (or get default if missing)
		sb.WriteString("\t\tstate := getState()\n\n")
	}

	if m.IsPayable {
		sb.WriteString(fmt.Sprintf("\t\tif !validatePayment(\"%s\") {\n", m.MinDeposit))
		sb.WriteString("\t\t\tenv.PanicStr(\"Insufficient payment\")\n")
		sb.WriteString("\t\t}\n\n")
	}

	sb.WriteString(generateParamParser(m))
	sb.WriteString("\n")

	sb.WriteString("\t\t// Call method\n")
	if len(m.Returns) > 0 {
		sb.WriteString("\t\tresult := ")
	} else {
		sb.WriteString("\t\t")
	}

	sb.WriteString("state.")
	sb.WriteString(m.Name)
	sb.WriteString("(")

	if len(m.Params) > 0 {
		if len(m.Params) == 1 && !isBasicType(m.Params[0].Type) {
			sb.WriteString("params")
		} else {
			for i, p := range m.Params {
				if i > 0 {
					sb.WriteString(", ")
				}
				sb.WriteString("params.")
				sb.WriteString(p.Name)
			}
		}
	}
	sb.WriteString(")\n\n")

	if m.IsMutating {
		sb.WriteString("\t\tsetState(state)\n\n")
	}

	if len(m.Returns) > 0 {
		sb.WriteString("\t\tresultJSON, err := encodingJson.Marshal(result)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tenv.PanicStr(\"Failed to marshal result to JSON\")\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tcontractBuilder.ReturnValue(string(resultJSON))\n")
	} else {
		sb.WriteString("\t\tsuccessJSON, _ := encodingJson.Marshal(map[string]string{\"status\": \"success\"})\n")
		sb.WriteString("\t\tcontractBuilder.ReturnValue(string(successJSON))\n")
	}

	sb.WriteString("\t\treturn nil\n")
	sb.WriteString("\t})\n")
	sb.WriteString("}\n")

	return sb.String()
}

func generateParamParser(method *MethodInfo) string {
	if len(method.Params) == 0 {
		return "\t\t// No parameters to parse\n"
	}

	var sb strings.Builder
	sb.WriteString("\t\t// Parse input parameters from JSON\n")

	if len(method.Params) == 1 && !isBasicType(method.Params[0].Type) {
		p := method.Params[0]
		sb.WriteString(fmt.Sprintf("\t\tvar params %s\n", p.Type))
		sb.WriteString("\t\terr := encodingJson.Unmarshal(input.Data, &params)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString(fmt.Sprintf("\t\t\tenv.LogString(\"JSON unmarshal error for %s: \" + err.Error())\n", p.Type))
		sb.WriteString(fmt.Sprintf("\t\t\tenv.PanicStr(\"Failed to parse %s parameter\")\n", p.Type))
		sb.WriteString("\t\t}\n")
	} else {
		sb.WriteString("\t\tvar params struct {\n")
		for _, p := range method.Params {
			jsonTag := fmt.Sprintf("`json:\"%s\"`", p.Name)
			sb.WriteString(fmt.Sprintf("\t\t\t%s %s %s\n", p.Name, p.Type, jsonTag))
		}
		sb.WriteString("\t\t}\n")

		sb.WriteString("\t\terr := encodingJson.Unmarshal(input.Data, &params)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tenv.LogString(\"JSON unmarshal error: \" + err.Error())\n")
		sb.WriteString("\t\t\tenv.PanicStr(\"Failed to parse input parameters\")\n")
		sb.WriteString("\t\t}\n")
	}

	return sb.String()
}

func isBasicType(typeStr string) bool {
	basicTypes := map[string]bool{
		"string":                 true,
		"bool":                   true,
		"int":                    true,
		"int8":                   true,
		"int16":                  true,
		"int32":                  true,
		"int64":                  true,
		"uint":                   true,
		"uint8":                  true,
		"uint16":                 true,
		"uint32":                 true,
		"uint64":                 true,
		"uintptr":                true,
		"byte":                   true,
		"rune":                   true,
		"float32":                true,
		"float64":                true,
		"complex64":              true,
		"complex128":             true,
		"[]byte":                 true,
		"[]string":               true,
		"[]int":                  true,
		"[]int64":                true,
		"[]float64":              true,
		"[]bool":                 true,
		"map[string]string":      true,
		"map[string]interface{}": true,
	}

	if basicTypes[typeStr] {
		return true
	}
	if strings.HasPrefix(typeStr, "*") {
		baseType := strings.TrimPrefix(typeStr, "*")
		return basicTypes[baseType]
	}
	if strings.HasPrefix(typeStr, "[]") {
		baseType := strings.TrimPrefix(typeStr, "[]")
		return basicTypes[baseType] || isBasicType(baseType)
	}
	if strings.HasPrefix(typeStr, "map[") {
		return true
	}
	return false
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}



==================================================
FILE: config.go
==================================================

package main

import "embed"

//go:embed template/**/*
var templates embed.FS

const (
	NearSdkGoVersion = "v0.0.13"

	SmartContractTypeProject   = "smart-contract-empty"
	SmartContractProjectFolder = "contract"

	ContractMainGoPath     = "template/contract/main.go.template"
	ContractMainGoFileName = "./main.go"

	ErrProvidedNetwork                   = "(USER_INPUT_ERROR): Missing 'network'"
	ErrProvidedNetworkAndAccountName     = "(USER_INPUT_ERROR): Missing both 'network' and 'account-name'"
	ErrProvidedNetworkAndContractId      = "(USER_INPUT_ERROR): Missing both 'network' and 'contract-id'"
	ErrProvidedProjectNameModuleNameType = "(USER_INPUT_ERROR): Missing 'project-name', 'module-name', or 'type'"
	ErrIncorrectType                     = "(USER_INPUT_ERROR): Invalid project type"
	ErrRunningNearCLI                    = "(INTERNAL_UTILS): Failed to execute Near CLI"
	ErrRunningCmd                        = "(INTERNAL_UTILS): Failed to start command"
	ErrGoProjectModFileIsMissing         = "(INTERNAL_PROJECT_CONTRACT): Missing 'go.mod' file"
	ErrGoProjectSumFileIsMissing         = "(INTERNAL_PROJECT_CONTRACT): Missing 'go.sum' file"
	ErrToReadFile                        = "(INTERNAL_PROJECT): Failed to read file"
	ErrBuildFailed                       = "(BUILD_ERROR): Build failed after retries"
	ErrWasmNotFound                      = "(BUILD_ERROR): WASM file not found after build"
	ErrNetworkUnreachable                = "(NETWORK_ERROR): Unable to download dependencies"
)



==================================================
FILE: main.go
==================================================

package main

import (
	"errors"
	"fmt"
	"os"

	"github.com/urfave/cli"
)

func main() {
	InitEmbeddedBins()
	CheckDependencies()

	app := &cli.App{
		Name:  "near-go",
		Usage: "CLI tool for managing projects on Near Blockchain",
		Commands: []cli.Command{
			{
				Name:  "create",
				Usage: "Create a new project",
				Flags: []cli.Flag{
					&cli.StringFlag{Name: "project-name, p", Required: true},
					&cli.StringFlag{Name: "module-name, m", Required: true},
					&cli.StringFlag{Name: "project-type, t", Required: true},
				},
				Action: func(c *cli.Context) error {
					if c.String("project-name") == "" || c.String("module-name") == "" {
						return errors.New(ErrProvidedProjectNameModuleNameType)
					}
					return HandleCreateProject(c.String("project-name"), c.String("project-type"), c.String("module-name"))
				},
			},
			{
				Name:  "build",
				Usage: "Build the project",
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:  "source, s",
						Usage: "Source directory to scan for smart contract code",
						Value: "./", // Default to current directory
					},
					&cli.StringFlag{
						Name:  "output, o",
						Usage: "Output filename for the WASM binary",
						Value: "main.wasm", // Default output name
					},
				},
				Action: func(c *cli.Context) error {
					// Call HandleBuild from builder.go, passing source and output flags
					return HandleBuild(c.String("source"), c.String("output"))
				},
			},
			{
				Name:  "test",
				Usage: "Run tests",
				Subcommands: []cli.Command{
					{
						Name:   "project",
						Action: func(c *cli.Context) error { return HandleTests("project") },
					},
					{
						Name:   "package",
						Action: func(c *cli.Context) error { return HandleTests("package") },
					},
				},
			},
			{
				Name:  "account",
				Usage: "Manage blockchain accounts",
				Subcommands: []cli.Command{
					{
						Name: "create",
						Flags: []cli.Flag{
							&cli.StringFlag{Name: "network, n", Required: true},
							&cli.StringFlag{Name: "account-name, a"},
						},
						Action: func(c *cli.Context) error {
							net, name := c.String("network"), c.String("account-name")
							if net == "" {
								return errors.New(ErrProvidedNetwork)
							}
							if net == "dev" && name == "" {
								return errors.New(ErrProvidedNetworkAndAccountName)
							}
							return HandleCreateAccount(net, name)
						},
					},
					{
						Name: "import",
						Action: func(c *cli.Context) error {
							return HandleImportAccount()
						},
					},
				},
			},
			{
				Name:  "deploy",
				Usage: "Deploy the project",
				Flags: []cli.Flag{
					&cli.StringFlag{Name: "contract-id, id", Required: true},
					&cli.StringFlag{Name: "network, n", Required: true},
					&cli.StringFlag{Name: "file, f", Usage: "WASM file to deploy", Value: "main.wasm"}, // Added file flag
				},
				Action: func(c *cli.Context) error {
					id, net := c.String("contract-id"), c.String("network")
					if id == "" || net == "" {
						return errors.New(ErrProvidedNetworkAndContractId)
					}
					// Note: HandleDeployContract currently uses a hardcoded "./main.wasm".
					// You would need to update HandleDeployContract in near.go to accept the file path if needed.
					return HandleDeployContract(id, net)
				},
			},
			{
				Name:  "call",
				Usage: "Call a smart contract function",
				Flags: []cli.Flag{
					&cli.StringFlag{Name: "signer, from", Required: true},
					&cli.StringFlag{Name: "contract, to", Required: true},
					&cli.StringFlag{Name: "method, function", Required: true},
					&cli.StringFlag{Name: "args", Value: "{}"},
					&cli.StringFlag{Name: "gas", Value: "100 Tgas"},
					&cli.StringFlag{Name: "deposit", Value: "0 NEAR"},
					&cli.StringFlag{Name: "network", Required: true},
				},
				Action: func(c *cli.Context) error {
					return HandleCallFunction(
						c.String("signer"), c.String("contract"),
						c.String("method"), c.String("args"),
						c.String("gas"), c.String("deposit"), c.String("network"),
					)
				},
			},
		},
	}

	if err := app.Run(os.Args); err != nil {
		fmt.Printf("Error: %v\n", err)
	}
}



==================================================
FILE: near.go
==================================================

package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
)

func runNearCLI(args ...string) error {
	cmd := exec.Command(filepath.Join(os.TempDir(), "near"), args...)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("%s: %w", ErrRunningNearCLI, err)
	}
	return nil
}

func HandleDeployContract(id, network string) error {
	args := []string{
		"contract", "deploy", id, "use-file", "./main.wasm",
		"without-init-call", "network-config", network,
		"sign-with-legacy-keychain", "send",
	}
	return runNearCLI(args...)
}

func HandleCreateAccount(network, name string) error {
	if network == "prod" {
		return runNearCLI("account", "create-account", "fund-later", "use-auto-generation", "save-to-folder", "./")
	}
	return runNearCLI("account", "create-account", "sponsor-by-faucet-service", name, 
		"autogenerate-new-keypair", "save-to-legacy-keychain", 
		"network-config", "testnet", "create")
}

func HandleImportAccount() error {
	return runNearCLI("account", "import-account")
}

func HandleCallFunction(signer, contract, method, args, gas, deposit, network string) error {
	cmd := []string{
		"contract", "call-function", "as-transaction", contract, method,
		"json-args", args, "prepaid-gas", gas, "attached-deposit", deposit,
		"sign-as", signer, "network-config", network,
		"sign-with-keychain", "send",
	}
	fmt.Printf("ðŸ“ž Calling %s on %s...\n", method, contract)
	return runNearCLI(cmd...)
}


==================================================
FILE: project.go
==================================================

package main

import (
	"fmt"
	"os"
)

func HandleCreateProject(projectName, projectType, moduleName string) error {
	if projectType != SmartContractTypeProject {
		return fmt.Errorf("%s", ErrIncorrectType)
	}

	fmt.Printf("ðŸš€ Creating project '%s'...\n", projectName)
	if err := CreateFolderAndNavigate(projectName); err != nil {
		return err
	}

	if err := initializeSmartContract(moduleName); err != nil {
		os.Chdir("..")
		os.RemoveAll(projectName)
		return err
	}

	return nil
}

func initializeSmartContract(moduleName string) error {
	if err := CreateFolderAndNavigate(SmartContractProjectFolder); err != nil {
		return err
	}

	fmt.Println("ðŸ“¦ Initializing Go module...")
	if _, err := ExecuteCommand("go", "mod", "init", moduleName); err != nil {
		return err
	}

	if _, err := os.Stat("go.mod"); os.IsNotExist(err) {
		return fmt.Errorf("%s", ErrGoProjectModFileIsMissing)
	}

	fmt.Println("ðŸ“¥ Downloading dependencies...")
	if _, err := ExecuteCommand("go", "get", fmt.Sprintf("github.com/vlmoon99/near-sdk-go@%s", NearSdkGoVersion)); err != nil {
		return err
	}

	if _, err := os.Stat("go.sum"); os.IsNotExist(err) {
		return fmt.Errorf("%s", ErrGoProjectSumFileIsMissing)
	}

	fmt.Println("ðŸ“ Creating template...")
	content, err := templates.ReadFile(ContractMainGoPath)
	if err != nil {
		return fmt.Errorf("%s %v", ErrToReadFile, err)
	}

	if err := WriteToFile(ContractMainGoFileName, string(content)); err != nil {
		return err
	}

	fmt.Println("âœ… Project created successfully!")
	return nil
}


==================================================
FILE: utils.go
==================================================

package main

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/vlmoon99/near-cli-go/bindata"
)

func InitEmbeddedBins() {
	nearCliPath := filepath.Join(os.TempDir(), "near")
	if _, err := os.Stat(nearCliPath); err == nil {
		return
	}
	if err := os.WriteFile(nearCliPath, bindata.NearCli, 0755); err != nil {
		panic("failed to write near-cli: " + err.Error())
	}
}

func CheckDependencies() {
	programs := map[string]string{
		"go":     "Go programming language",
		"tinygo": "TinyGo compiler",
	}
	missing := []string{}
	for prog := range programs {
		if _, err := exec.LookPath(prog); err != nil {
			missing = append(missing, prog)
		}
	}
	if len(missing) > 0 {
		fmt.Printf("Missing dependencies: %s\n", strings.Join(missing, ", "))
		os.Exit(1)
	}
}

func WriteToFile(filename, content string) error {
	return os.WriteFile(filename, []byte(content), 0644)
}

func CreateFolderAndNavigate(name string) error {
	if err := os.MkdirAll(name, os.ModePerm); err != nil {
		return err
	}
	return os.Chdir(name)
}

func ExecuteCommand(name string, args ...string) ([]byte, error) {
	var stdout, stderr bytes.Buffer
	cmd := exec.Command(name, args...)
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		errStr := stderr.String()
		if strings.Contains(errStr, "network is unreachable") || strings.Contains(errStr, "no route to host") {
			return nil, fmt.Errorf("%s", ErrNetworkUnreachable)
		}
		return nil, fmt.Errorf("%s: %v: %s", ErrRunningCmd, err, errStr)
	}
	return stdout.Bytes(), nil
}

func ExecuteWithRetry(name string, args []string, dir string, retries int, debug bool) error {
	var lastErr error
	for i := range retries {
		cmd := exec.Command(name, args...)

		// Set the working directory if provided
		if dir != "" {
			cmd.Dir = dir
		}

		output, err := cmd.CombinedOutput()
		if err == nil {
			if debug {
				fmt.Println(string(output))
			}
			return nil
		}
		lastErr = err
		if debug || i == retries-1 {
			fmt.Printf("Attempt %d failed: %s\nOutput: %s\n", i+1, err, string(output))
		}
	}
	return fmt.Errorf("%s: %v", ErrBuildFailed, lastErr)
}



