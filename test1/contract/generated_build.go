// Code generated by NEAR contract generator. DO NOT EDIT.
// This file uses encoding/json for parameter parsing instead of Borsh.

package main

import (
	encodingJson "encoding/json"
	"strconv"
	"test1/a"

	"github.com/vlmoon99/near-sdk-go/borsh"
	contractBuilder "github.com/vlmoon99/near-sdk-go/contract"
	"github.com/vlmoon99/near-sdk-go/env"
	"github.com/vlmoon99/near-sdk-go/types"
)

// ===== From: main.go =====
type Contract struct {
	Message string
}

func (c *Contract) Init(msg string) {
	c.Message = msg
}

func (c *Contract) GetMessage() string {
	msg := a.Hello()
	return c.Message + " " + msg
}

func (c *Contract) SetMessage(newMessage string) {
	c.Message = newMessage
}

func defaultInit() *Contract {
	return &Contract{}
}
func getState() *Contract {
	val, err := env.StateRead()
	if err != nil || len(val) == 0 {
		return defaultInit()
	}
	var state Contract
	err = borsh.Deserialize(val, &state)
	if err != nil {
		env.PanicStr("Failed to deserialize state")
	}
	return &state
}

func setState(state *Contract) {
	val, err := borsh.Serialize(state)
	if err != nil {
		env.PanicStr("Failed to serialize state")
	}
	err = env.StateWrite(val)
	if err != nil {
		env.PanicStr("Failed to write state")
	}
}

// ===== Generated Exports =====
// Export: init (from main.go)
//
//go:export init
func init() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		// // Initialization: Check if already initialized
		// existingVal, _ := env.StateRead()
		// if len(existingVal) > 0 {
		// 	env.PanicStr("Contract already initialized")
		// }
		state := defaultInit()

		// Parse input parameters from JSON
		var params struct {
			msg string `json:"msg"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		state.Init(params.msg)

		setState(state)

		successJSON, _ := encodingJson.Marshal(map[string]string{"status": "success"})
		contractBuilder.ReturnValue(string(successJSON))
		return nil
	})
}

// Export: get_message (from main.go)
//
//go:export get_message
func get_message() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		state := getState()

		// No parameters to parse

		// Call method
		result := state.GetMessage()

		resultJSON, err := encodingJson.Marshal(result)
		if err != nil {
			env.PanicStr("Failed to marshal result to JSON")
		}
		contractBuilder.ReturnValue(string(resultJSON))
		return nil
	})
}

// Export: set_message (from main.go)
//
//go:export set_message
func set_message() {
	contractBuilder.HandleClientJSONInput(func(input *contractBuilder.ContractInput) error {
		state := getState()

		// Parse input parameters from JSON
		var params struct {
			newMessage string `json:"newMessage"`
		}
		err := encodingJson.Unmarshal(input.Data, &params)
		if err != nil {
			env.LogString("JSON unmarshal error: " + err.Error())
			env.PanicStr("Failed to parse input parameters")
		}

		// Call method
		state.SetMessage(params.newMessage)

		setState(state)

		contractBuilder.ReturnValue(string("OK"))
		return nil
	})
}

// ===== Helper Functions =====
func validatePayment(minDeposit string) bool {
	minAmount, err := strconv.ParseFloat(minDeposit, 64)
	if err != nil {
		env.LogString("Invalid min deposit amount: " + minDeposit)
		return false
	}
	minYocto := minAmount * 1e24
	minYoctoStr := strconv.FormatFloat(minYocto, 'f', 0, 64)
	minRequired, err := types.U128FromString(minYoctoStr)
	if err != nil {
		env.LogString("Failed to create Uint128: " + err.Error())
		return false
	}
	attachedDeposit, err := env.GetAttachedDeposit()
	if attachedDeposit.Cmp(minRequired) < 0 {
		env.LogString("Insufficient payment")
		return false
	}
	return true
}
